#include "../headers/__esbmc/solidity.h"

const char *sol_header =
  "#include <stddef.h>\n"
  "#include <stdlib.h>\n"
  "#include <stdint.h>\n"
  "#include <string.h>\n"
  "#include <stdbool.h>\n";

const char *sol_typedef =
  "typedef _ExtInt(256) int256_t;\n"
  "typedef unsigned _ExtInt(128) uint128_t;\n"
  "typedef unsigned _ExtInt(160) address_t;\n";

const char *sol_msg =
  "uint128_t msg_data;\n"
  "address_t msg_sender;\n"
  "__uint32_t msg_sig;\n"
  "uint128_t msg_value;\n";

const char *sol_tx =
  "uint128_t tx_gasprice;\n"
  "address_t tx_origin;\n";

const char *sol_block =
  "uint128_t block_basefee;\n"
  "uint128_t block_chainid;\n"
  "address_t block_coinbase;\n"
  "uint128_t block_difficulty;\n"
  "uint128_t block_gaslimit;\n"
  "uint128_t block_number;\n"
  "uint128_t block_prevrandao;\n"
  "uint128_t block_timestamp;\n";

const char *sol_vars =
  "uint128_t msg_data;\n"
  "address_t msg_sender;\n"
  "__uint32_t msg_sig;\n"
  "uint128_t msg_value;\n"
  "uint128_t tx_gasprice;\n"
  "address_t tx_origin;\n"
  "uint128_t block_basefee;\n"
  "uint128_t block_chainid;\n"
  "address_t block_coinbase;\n"
  "uint128_t block_difficulty;\n"
  "uint128_t block_gaslimit;\n"
  "uint128_t block_number;\n"
  "uint128_t block_prevrandao;\n"
  "uint128_t block_timestamp;\n";

const char *blockhash = "uint128_t blockhash();\n";

const char *gasleft = "uint128_t gasleft();\n";

const char *sol_abi =
  "uint128_t abi_encode();\n"
  "uint128_t abi_encodePacked();\n"
  "uint128_t abi_encodeWithSelector();\n"
  "uint128_t abi_encodeWithSignature();\n"
  "uint128_t abi_encodeCall();\n";

const char *sol_math =
  "uint128_t addmod(uint128_t x, uint128_t y, uint128_t k)\n"
  "{\n"
  "    return (x + y) % k;\n"
  "}\n"
  "\n"
  "uint128_t mulmod(uint128_t x, uint128_t y, uint128_t k)\n"
  "{\n"
  "    return (x * y) % k;\n"
  "}\n"
  "\n"
  "uint128_t keccak256();\n"
  "uint128_t sha256();\n"
  "address_t ripemd160();\n"
  "address_t ecrecover();\n";

const char *sol_string =
  "char* string_concat(char *x, char *y)\n"
  "{\n"
  "   strcat(x, y);\n"
  "   return x;\n"
  "}\n";

const char *sol_byte = "void byte_concat();\n";

const char *sol_mapping =
  "struct map_node_t;\n"
  "typedef struct map_node_t map_node_t;\n"
  "int zero_int;\n"
  "unsigned int zero_uint;\n"
  "bool zero_bool;\n"
  "char *zero_string;\n"
  "typedef struct map_base_t\n"
  "{\n"
  "    map_node_t **buckets;\n"
  "    unsigned nbuckets, nnodes;\n"
  "} map_base_t;\n"
  "typedef struct map_iter_t\n"
  "{\n"
  "    unsigned bucketidx;\n"
  "    map_node_t *node;\n"
  "} map_iter_t;\n"
  "typedef struct map_node_t\n"
  "{\n"
  "    unsigned hash;\n"
  "    void *value;\n"
  "    map_node_t *next;\n"
  "} map_node_t;\n"
  "void *map_get_(map_base_t *m, const char *key);\n"
  "int map_set_(map_base_t *m, const char *key, void *value, int vsize);\n"
  "void map_remove_(map_base_t *m, const char *key);\n"
  "typedef struct map_int_t\n"
  "{\n"
  "    map_base_t base;\n"
  "    int *ref;\n"
  "    int tmp;\n"
  "} map_int_t;\n"
  "typedef struct map_uint_t\n"
  "{\n"
  "    map_base_t base;\n"
  "    unsigned int *ref;\n"
  "    unsigned int tmp;\n"
  "} map_uint_t;\n"
  "typedef struct map_string_t\n"
  "{\n"
  "    map_base_t base;\n"
  "    char **ref;\n"
  "    char *tmp;\n"
  "} map_string_t;\n"
  "typedef struct map_bool_t\n"
  "{\n"
  "    map_base_t base;\n"
  "    bool *ref;\n"
  "    bool tmp;\n"
  "} map_bool_t;\n"
  "void map_init_int(map_int_t *m)\n"
  "{\n"
  "    memset(m, 0, sizeof(*(m)));\n"
  "}\n"
  "void map_init_uint(map_uint_t *m)\n"
  "{\n"
  "    memset(m, 0, sizeof(*(m)));\n"
  "}\n"
  "void map_init_string(map_string_t *m)\n"
  "{\n"
  "    memset(m, 0, sizeof(*(m)));\n"
  "}\n"
  "void map_init_bool(map_bool_t *m)\n"
  "{\n"
  "    memset(m, 0, sizeof(*(m)));\n"
  "}\n"
  "void map_set_int(map_int_t *m, const char *key, const int value)\n"
  "{\n"
  "    (m)->tmp = value;\n"
  "    map_set_(&(m)->base, key, &(m)->tmp, sizeof((m)->tmp));\n"
  "}\n"
  "void map_set_uint(map_uint_t *m, const char *key, const unsigned int "
  "value)\n"
  "{\n"
  "    (m)->tmp = value;\n"
  "    map_set_(&(m)->base, key, &(m)->tmp, sizeof((m)->tmp));\n"
  "}\n"
  "void map_set_string(map_string_t *m, const char *key, char *value)\n"
  "{\n"
  "    (m)->tmp = value;\n"
  "    map_set_(&(m)->base, key, &(m)->tmp, sizeof((m)->tmp));\n"
  "}\n"
  "void map_set_bool(map_bool_t *m, const char *key, const bool value)\n"
  "{\n"
  "    (m)->tmp = value;\n"
  "    map_set_(&(m)->base, key, &(m)->tmp, sizeof((m)->tmp));\n"
  "}\n"
  "int *map_get_int(map_int_t *m, const char *key)\n"
  "{\n"
  "    (m)->ref = map_get_(&(m)->base, key);\n"
  "    zero_int = 0;\n"
  "    return (m)->ref != NULL ? (m)->ref : &zero_int;\n"
  "}\n"
  "unsigned int *map_get_uint(map_uint_t *m, const char *key)\n"
  "{\n"
  "    (m)->ref = map_get_(&(m)->base, key);\n"
  "    zero_uint = 0;\n"
  "    return (m)->ref != NULL ? (m)->ref : &zero_uint;\n"
  "}\n"
  "char **map_get_string(map_string_t *m, const char *key)\n"
  "{\n"
  "    (m)->ref = map_get_(&(m)->base, key);\n"
  "    zero_string = \"0\";\n"
  "    return (m)->ref != NULL ? (m)->ref : &zero_string;\n"
  "}\n"
  "bool *map_get_bool(map_bool_t *m, const char *key)\n"
  "{\n"
  "    (m)->ref = map_get_(&(m)->base, key);\n"
  "    zero_bool = false;\n"
  "    return (m)->ref != NULL ? (m)->ref : &zero_bool;\n"
  "}\n"
  "unsigned map_hash(const char *str)\n"
  "{\n"
  "    unsigned hash = 5381;\n"
  "    if (str != NULL)\n"
  "        while (*str)\n"
  "        {\n"
  "            hash = ((hash << 5) + hash) ^ *str++;\n"
  "        }\n"
  "    return hash;\n"
  "}\n"
  "map_node_t *map_newnode(const char *key, void *value, int vsize)\n"
  "{\n"
  "    map_node_t *node;\n"
  "    int ksize = strlen(key) + 1;\n"
  "    int voffset = ksize + ((sizeof(void *) - ksize) % sizeof(void *));\n"
  "    node = malloc(sizeof(*node) + voffset + vsize);\n"
  "    if (!node)\n"
  "        return NULL;\n"
  "    memcpy(node + 1, key, ksize);\n"
  "    node->hash = map_hash(key);\n"
  "    node->value = ((char *)(node + 1)) + voffset;\n"
  "    memcpy(node->value, value, vsize);\n"
  "    return node;\n"
  "}\n"
  "int map_bucketidx(map_base_t *m, unsigned hash)\n"
  "{\n"
  "    return hash & (m->nbuckets - 1);\n"
  "}\n"
  "void map_addnode(map_base_t *m, map_node_t *node)\n"
  "{\n"
  "    int n = map_bucketidx(m, node->hash);\n"
  "    node->next = m->buckets[n];\n"
  "    m->buckets[n] = node;\n"
  "}\n"
  "int map_resize(map_base_t *m, int nbuckets)\n"
  "{\n"
  "    map_node_t *nodes, *node, *next;\n"
  "    map_node_t **buckets;\n"
  "    int i;\n"
  "    nodes = NULL;\n"
  "    i = m->nbuckets;\n"
  "    while (i--)\n"
  "    {\n"
  "        node = (m->buckets)[i];\n"
  "        while (node)\n"
  "        {\n"
  "            next = node->next;\n"
  "            node->next = nodes;\n"
  "            nodes = node;\n"
  "            node = next;\n"
  "        }\n"
  "    }\n"
  "    buckets = malloc(sizeof(*m->buckets) * nbuckets);\n"
  "    if (buckets != NULL)\n"
  "    {\n"
  "        m->buckets = buckets;\n"
  "        m->nbuckets = nbuckets;\n"
  "    }\n"
  "    if (m->buckets)\n"
  "    {\n"
  "        memset(m->buckets, 0, sizeof(*m->buckets) * m->nbuckets);\n"
  "        node = nodes;\n"
  "        while (node)\n"
  "        {\n"
  "            next = node->next;\n"
  "            map_addnode(m, node);\n"
  "            node = next;\n"
  "        }\n"
  "    }\n"
  "    return 0;\n"
  "}\n"
  "map_node_t **map_getref(map_base_t *m, const char *key)\n"
  "{\n"
  "    unsigned hash = map_hash(key);\n"
  "    map_node_t **next;\n"
  "    if (m->nbuckets > 0)\n"
  "    {\n"
  "        next = &m->buckets[map_bucketidx(m, hash)];\n"
  "        while (*next)\n"
  "        {\n"
  "            if ((*next)->hash == hash && !strcmp((char *)(*next + 1), "
  "key))\n"
  "            {\n"
  "                return next;\n"
  "            }\n"
  "            next = &(*next)->next;\n"
  "        }\n"
  "    }\n"
  "    return NULL;\n"
  "}\n"
  "void *map_get_(map_base_t *m, const char *key)\n"
  "{\n"
  "    map_node_t **next = map_getref(m, key);\n"
  "    return next ? (*next)->value : NULL;\n"
  "}\n"
  "int map_set_(map_base_t *m, const char *key, void *value, int vsize)\n"
  "{\n"
  "    int n, err;\n"
  "    map_node_t **next, *node;\n"
  "    next = map_getref(m, key);\n"
  "    if (next)\n"
  "    {\n"
  "        memcpy((*next)->value, value, vsize);\n"
  "        return 0;\n"
  "    }\n"
  "    node = map_newnode(key, value, vsize);\n"
  "    if (node == NULL)\n"
  "        return -1;\n"
  "    if (m->nnodes >= m->nbuckets)\n"
  "    {\n"
  "        n = (m->nbuckets > 0) ? (m->nbuckets << 1) : 1;\n"
  "        err = map_resize(m, n);\n"
  "        if (err)\n"
  "            return -1;\n"
  "    }\n"
  "    map_addnode(m, node);\n"
  "    m->nnodes++;\n"
  "    return 0;\n"
  "}\n"
  "void map_remove_(map_base_t *m, const char *key)\n"
  "{\n"
  "    map_node_t *node;\n"
  "    map_node_t **next = map_getref(m, key);\n"
  "    if (next)\n"
  "    {\n"
  "        node = *next;\n"
  "        *next = (*next)->next;\n"
  "        free(node);\n"
  "        m->nnodes--;\n"
  "    }\n"
  "}\n";

/// external library
// itoa
const char *sol_itoa =
  "char get_char(int digit)\n"
  "{\n"
  "    char charstr[] = \"0123456789ABCDEF\";\n"
  "    return charstr[digit];\n"
  "}\n"
  "void rev(char *p)\n"
  "{\n"
  "    char *q = &p[strlen(p) - 1];\n"
  "    char *r = p;\n"
  "    for (; q > r; q--, r++)\n"
  "    {\n"
  "        char s = *q;\n"
  "        *q = *r;\n"
  "        *r = s;\n"
  "    }\n"
  "}\n"
  "char *i256toa(int256_t value)\n"
  "{\n"
  "    // we might have memory leak as we will not free this afterwards\n"
  "    char *str = (char *)malloc(256 * sizeof(char));\n"
  "    int256_t base = (int256_t)10;\n"
  "    unsigned short count = 0;\n"
  "    bool flag = true;\n"
  "\n"
  "    if (value < (int256_t)0 && base == (int256_t)10)\n"
  "    {\n"
  "        flag = false;\n"
  "    }\n"
  "    if (value == (int256_t)0)\n"
  "    {\n"
  "        str[count] = '\\0';\n"
  "        return str;\n"
  "    }\n"
  "    while (value != (int256_t)0)\n"
  "    {\n"
  "        int256_t dig = value % base;\n"
  "        value -= dig;\n"
  "        value /= base;\n"
  "\n"
  "        if (flag == true)\n"
  "            str[count] = get_char(dig);\n"
  "        else\n"
  "            str[count] = get_char(-dig);\n"
  "        count++;\n"
  "    }\n"
  "    if (flag == false)\n"
  "    {\n"
  "        str[count] = '-';\n"
  "        count++;\n"
  "    }\n"
  "    str[count] = 0;\n"
  "    rev(str);\n"
  "    return str;\n"
  "}\n"
  "\n"
  "char *u256toa(uint128_t value)\n"
  "{\n"
  "    char *str = (char *)malloc(256 * sizeof(char));\n"
  "    uint128_t base = (uint128_t)10;\n"
  "    unsigned short count = 0;\n"
  "    if (value == (uint128_t)0)\n"
  "    {\n"
  "        str[count] = '\\0';\n"
  "        return str;\n"
  "}\n"
  "    while (value != (uint128_t)0)\n"
  "    {\n"
  "        uint128_t dig = value % base;\n"
  "        value -= dig;\n"
  "        value /= base;\n"
  "        str[count] = get_char(dig);\n"
  "        count++;\n"
  "    }\n"
  "    str[count] = 0;\n"
  "    rev(str);\n"
  "    return str;\n"
  "}\n";

//const char *sol_ext_library = sol_itoa;

// combination
const char *sol_library =
  "#include <stddef.h>\n"
  "#include <stdlib.h>\n"
  "#include <stdint.h>\n"
  "#include <string.h>\n"
  "#include <stdbool.h>\n"
  "typedef _ExtInt(256) int256_t;\n"
  "typedef unsigned _ExtInt(256) uint128_t;\n"
  "typedef unsigned _ExtInt(160) address_t;\n"
  "uint128_t msg_data;\n"
  "address_t msg_sender;\n"
  "__uint32_t msg_sig;\n"
  "uint128_t msg_value;\n"
  "uint128_t tx_gasprice;\n"
  "address_t tx_origin;\n"
  "uint128_t block_basefee;\n"
  "uint128_t block_chainid;\n"
  "address_t block_coinbase;\n"
  "uint128_t block_difficulty;\n"
  "uint128_t block_gaslimit;\n"
  "uint128_t block_number;\n"
  "uint128_t block_prevrandao;\n"
  "uint128_t block_timestamp;\n"
  "uint128_t blockhash();\n"
  "uint128_t gasleft();\n"
  "uint128_t abi_encode();\n"
  "uint128_t abi_encodePacked();\n"
  "uint128_t abi_encodeWithSelector();\n"
  "uint128_t abi_encodeWithSignature();\n"
  "uint128_t abi_encodeCall();\n"
  "uint128_t addmod(uint128_t x, uint128_t y, uint128_t k)\n"
  "{\n"
  "    return (x + y) % k;\n"
  "}\n"
  "uint128_t mulmod(uint128_t x, uint128_t y, uint128_t k)\n"
  "{\n"
  "    return (x * y) % k;\n"
  "}\n"
  "uint128_t keccak256();\n"
  "uint128_t sha256();\n"
  "address_t ripemd160();\n"
  "address_t ecrecover();\n"
  "typedef struct map_node_t\n"
  "{\n"
  "    struct map_node_t *next;\n"
  "    const char *key;\n"
  "    const void *value;\n"
  "} map_node_t;\n"
  "typedef struct\n"
  "{\n"
  "    size_t nnodes, order, size;\n"
  "    map_node_t **buckets;\n"
  "} map_base_t;\n"
  "#define MAP_INITIALIZER {0, 0, 0, 0}\n"
  "const void *map_get(const map_base_t *m, const char *key)\n"
  "{\n"
  "    const map_node_t *node;\n"
  "    if (!m->nnodes)\n"
  "        return 0;\n"
  "    node = *map_getref(m, key);\n"
  "    return node ? node->value : 0;\n"
  "}\n"
  "void map_set(map_base_t *m, const char *key, const void *value)\n"
  "{\n"
  "    map_node_t **next = map_getref(m, key);\n"
  "    map_node_t *node = *next;\n"
  "    if (node)\n"
  "    {\n"
  "        node->value = value;\n"
  "        return;\n"
  "    }\n"
  "    if (m->nnodes >= (m->size * m->order) / 2)\n"
  "    {\n"
  "        if (map_resize(m, m->size * 2) < 0)\n"
  "            return;\n"
  "        next = map_getref(m, key);\n"
  "    }\n"
  "    node = (map_node_t *)malloc(sizeof(*node));\n"
  "    if (!node)\n"
  "        return;\n"
  "    node->key = key;\n"
  "    node->value = value;\n"
  "    node->next = *next;\n"
  "    *next = node;\n"
  "    m->nnodes++;\n"
  "}\n"
  "void map_remove(map_base_t *m, const char *key)\n"
  "{\n"
  "    map_node_t *node;\n"
  "    map_node_t **next = map_getref(m, key);\n"
  "    if (next)\n"
  "    {\n"
  "        node = *next;\n"
  "        *next = (*next)->next;\n"
  "        free(node);\n"
  "        m->nnodes--;\n"
  "    }\n"
  "}\n"
  "void map_free(map_base_t *m)\n"
  "{\n"
  "    map_node_t *next, *node;\n"
  "    size_t i;\n"
  "    for (i = 0; i < m->size; i++)\n"
  "    {\n"
  "        node = m->buckets[i];\n"
  "        while (node)\n"
  "        {\n"
  "            next = node->next;\n"
  "            free(node);\n"
  "            node = next;\n"
  "        }\n"
  "    }\n"
  "    free(m->buckets);\n"
  "    m->size = 0;\n"
  "    m->nnodes = 0;\n"
  "}\n"
  "const void *map_get_(const map_base_t *m, const char *key)\n"
  "{\n"
  "    const map_node_t *node;\n"
  "    if (!m->nnodes)\n"
  "        return 0;\n"
  "    node = *map_getref(m, key);\n"
  "    return node ? node->value : 0;\n"
  "}\n"
  "void map_set_(map_base_t *m, const char *key, const void *value)\n"
  "{\n"
  "    map_node_t **next = map_getref(m, key);\n"
  "    map_node_t *node = *next;\n"
  "    if (node)\n"
  "    {\n"
  "        node->value = value;\n"
  "        return;\n"
  "    }\n"
  "    if (m->nnodes >= (m->size * m->order) / 2)\n"
  "    {\n"
  "        if (map_resize(m, m->size * 2) < 0)\n"
  "            return;\n"
  "        next = map_getref(m, key);\n"
  "    }\n"
  "    node = (map_node_t *)malloc(sizeof(*node));\n"
  "    if (!node)\n"
  "        return;\n"
  "    node->key = key;\n"
  "    node->value = value;\n"
  "    node->next = *next;\n"
  "    *next = node;\n"
  "    m->nnodes++;\n"
  "}\n"
  "void map_remove_(map_base_t *m, const char *key)\n"
  "{\n"
  "    map_node_t *node;\n"
  "    map_node_t **next = map_getref(m, key);\n"
  "    if (next)\n"
  "    {\n"
  "        node = *next;\n"
  "        *next = (*next)->next;\n"
  "        free(node);\n"
  "        m->nnodes--;\n"
  "    }\n"
  "}\n";
